# OCP5DateTime
Работа с датами и временем
В Java 8 Oracle полностью обновила методы работы с датами и временем. Вы все еще можете написать код по-старому, но эти классы не на экзамене. Мы упомянем старый способ в реальных сценариях, чтобы вы могли легче изучить новый способ, если вы изучили Java до версии 8. Даже если вы изучаете Java, начиная с версии 8, это поможет вам, когда вам нужно читать старый код Просто знайте, что по-старому не на экзамене.
Вам нужно importработать с датой и временем занятий. Большинство из них находятся в java.timeупаковке. Чтобы использовать его, добавьте это importв вашу программу:
import java.time.*;          // import time classes

День против даты
В американском английском слово date используется для обозначения двух разных понятий. Иногда это комбинация месяц / день / год, когда что-то произошло, например, 1 января 2000 года. Иногда это день месяца, например, сегодняшняя дата - шестая.
Вот так; слова день и дата часто используются как синонимы. Будьте внимательны к этому на экзамене, особенно если вы живете в каком-то месте, где люди более точно говорят об этом различии.
В следующих разделах мы рассмотрим создание, манипулирование и форматирование дат и времени.
Создание даты и времени
В реальном мире мы обычно говорим о датах и часовых поясах, как будто другой человек находится рядом с нами. Например, если вы скажете мне: «Я позвоню вам в 11:00 во вторник утром», мы предполагаем, что 11:00 означает то же самое для нас обоих. Но если я живу в Нью-Йорке, а вы живете в Калифорнии, мы должны быть более конкретными. Калифорния на три часа раньше Нью-Йорка, потому что штаты находятся в разных часовых поясах. Вместо этого вы скажете: «Я позвоню вам в 11:00 по восточному поясному времени во вторник утром». В отличие от OCA, вы должны знать о часовых поясах на OCP.
При работе с датами и временем первое, что нужно сделать, это решить, какой объем информации вам нужен. Экзамен дает вам четыре варианта:LocalDate  Содержит только дату - без времени и без часового пояса. Хорошим примером
 LocalDateявляется ваш день рождения в этом году. Это твой день рождения на целый день, независимо от того, который час.
LocalTime  Содержит только время - без даты и без часового пояса. Хорошим примером LocalTimeявляется полночь. Это полночь каждый день в одно и то же время.
LocalDateTime  Содержит дату и время, но без часового пояса. Хороший пример LocalDateTime- «полночный удар в канун Нового года». Полночь 2 января не такая уж особенная, что делает дату относительно неважной, и, очевидно, час после полуночи тоже не такой уж особенный.
ZonedDateTime  Содержит дату, время и часовой пояс. Хорошим примером ZonedDateTimeявляется «конференц-связь в 9:00 утра по восточному поясному времени». Если вы живете в Калифорнии, вам придется вставать очень рано, поскольку звонок в 6:00 по местному времени!
Oracle рекомендует избегать часовых поясов, если они вам действительно не нужны. Попытайтесь вести себя так, как будто все находятся в одном часовом поясе, когда можете.
Как вы помните из ОСА, вы получаете экземпляры даты и времени, используя staticметод:
System.out.println(LocalDate.now());
System.out.println(LocalTime.now());
System.out.println(LocalDateTime.now());
System.out.println(ZonedDateTime.now());
У каждого из четырех классов есть staticметод now(), который выдает текущую дату и время. Ваш вывод будет зависеть от даты / времени, когда вы запускаете его и где вы живете. Авторы живут в Соединенных Штатах, делая вывод, похожий на следующий, при запуске 25 мая в 9:13:

2015–05–25
09:13:07.768
2015–05–25T09:13:07.768
2015–05–25T09:13:07.769–04:00[America/New_York]
Ключ - это тип информации в выводе. Первая строка содержит только дату и без времени. Второй содержит только время и без даты. Время отображает часы, минуты, секунды и доли секунды. Третий содержит как дату, так и время. Java использует Tдля разделения даты и времени при преобразовании LocalDateTimeв String. Наконец, четвертый добавляет смещение часового пояса и часовой пояс. Нью-Йорк находится в четырех часовых поясах от среднего времени по Гринвичу (GMT).
Greenwich Mean Timeчасовой пояс в Европе, который используется как нулевой часовой пояс при обсуждении смещений. Возможно, вы также слышали Coordinated Universal Time, что является стандартом часового пояса. Это сокращенно как UTC, как компромисс между английскими и французскими названиями. (Это не опечатка. UTC на самом деле не является правильной аббревиатурой на любом языке!) UTC использует тот же ноль часового пояса, что и GMT.
Давайте убедимся, что вы понимаете, как работает UTC. Мы включили названия часовых поясов в примеры, чтобы их было проще изобразить. Экзамен даст вам смещение UTC. Вы не должны запоминать какие-либо часовые пояса.
Во-первых, давайте попробуем выяснить, насколько далеко эти моменты находятся во времени. Обратите внимание, что у Индии есть полчаса, а не целый час. Чтобы подойти к такой проблеме, вы вычтите часовой пояс из времени. Это дает вам время по Гринвичу:

2015–06–20T07:50+02:00[Europe/Paris]   // GMT
 2015–06–20 5:502015–06–20T06:50+05:30[Asia/Kolkata]   // GMT 2015–06–20 1:20
После преобразования в GMT вы можете увидеть, что парижское время на четыре с половиной часа отстает от Калькуттского.  
   Смещение часового пояса может быть указано по-разному: +02: 00, GMT + 2 и UTC + 2 означают одно и то же. Вы можете увидеть любого из них на экзамене.
Давайте попробуем еще один, на этот раз с GMT. Помните, что вам нужно добавить при вычитании отрицательного числа.

2015–06–20T07:50 GMT-04:00  // GMT 2015–06–20 11:50
2015–06–20T04:50 GMT-07:00  // GMT 2015–06–20 11:50
Для этого примера оба момента времени одинаковы. Восточный часовой пояс США на три часа опережает тихоокеанский часовой пояс США.
Если у вас возникли проблемы с запоминанием этого, попробуйте запомнить один пример, где часовые пояса находятся на расстоянии нескольких зон, и запомните направление. В Соединенных Штатах большинство людей знают, что восточное побережье на три часа впереди западного. И большинство людей знают, что Азия опережает Европу. Просто не пересекайте нулевой часовой пояс в примере, который вы решили запомнить. Расчет работает так же, но это не так хорошо, как помощь памяти.
Кстати, сколько часов между Калифорнией, Тихоокеанским часовым поясом и Индией? Попробуйте поработать над этим самостоятельно. Действительно, возьми ручку и напиши. Вы должны быть в состоянии выполнить эту математику на экзамене.
2015–06–20T07:50–07:00[US/Pacific]
2015–06–20T07:50+05:30[Asia/Kolkata]

Ответ 12 с половиной часов. Первый случай во времени - GMT 14:50. Второе время GMT 2:20. Неудивительно, что звонки между Калифорнией и Индией не удобны!
Подождите, я не живу в Соединенных Штатах
Экзамен признает, что экзаменующиеся живут по всему миру, и не спросит вас о деталях форматов даты и времени в США.
В Соединенных Штатах месяц написан до даты. Экзамен не спросит вас о разнице между 03.03.2015 и 03.02.2015. Это было бы подло и не для международного сообщества, и это будет проверять ваше знание дат США, а не знание Java. Тем не менее, наши примеры используют американские форматы даты и времени, как и вопросы на экзамене. Просто помните, что месяц предшествует дате. Также Java имеет тенденцию использовать 24-часовые часы, хотя Соединенные Штаты используют 12-часовые часы с am / pm.
Теперь, когда вы знаете, как создать текущую дату и время, давайте посмотрим на другие конкретные даты и время. Для начала давайте создадим просто дату без времени. Оба эти примера создают одну и ту же дату:
LocalDate date1 = LocalDate.of(2015, Month.JANUARY, 20);
LocalDate date2 = LocalDate.of(2015, 1, 20);

Оба проходят в год, месяц и дату. Хотя использовать Monthконстанты (для облегчения чтения кода ) полезно , вы можете передать intномер месяца напрямую. Просто используйте номер месяца так же, как если бы вы писали дату в реальной жизни.
Подписи метода следующие:
public static LocalDate of(int year, int month, int dayOfMonth)
public static LocalDate of(int year, Month month, int dayOfMonth)

Monthявляется enum. Помните, что an enumне является intи не может сравниваться с одним, например:
12:   Month month = Month.JANUARY;
13:   boolean b1 = month == 1;            // DOES NOT COMPILE
14:   boolean b2 = month == Month.APRIL;  // false
Строка 13 не компилируется, потому что enumэто другой тип, чем int. Строка 14 показывает, как правильно сравнивать enumзначения. 
    До сих пор мы постоянно говорили вам, что число Java начинается с 0. Ну, месяцы - исключение. В течение многих месяцев в новых методах даты и времени Java считает, начиная с 1, как и мы, люди.
При создании времени вы можете выбрать, насколько подробным вы хотите быть. Вы можете указать только часы и минуты или указать количество секунд. Вы можете даже включить наносекунды, если хотите быть очень точными. (Наносекунда - это миллиардная доля секунды, хотя вам, вероятно, не нужно быть таким конкретным.)


LocalTime time1 =  LocalTime.of(6, 15);               // hour and minute
LocalTime time2 =  LocalTime.of(6, 15, 30);          // + seconds
LocalTime time3 =  LocalTime.of(6, 15, 30, 200);     // + nanoseconds

Эти три раза все разные, но в течение минуты друг от друга. Подписи метода следующие:

public static LocalTime of(int hour, int minute)
public static LocalTime of(int hour, int minute, int second)
public static LocalTime of(int hour, int minute, int second, int nanos)
Вы можете объединить даты и время в один объект:

LocalDateTime dateTime1 = LocalDateTime.of(2015, Month.JANUARY, 20, 6, 15, 30);
LocalDateTime dateTime2 = LocalDateTime.of(date1, time1);
Первая строка кода показывает, как вы можете указать всю информацию о LocalDateTimeправе в одной строке. Существует множество сигнатур методов, позволяющих указывать разные вещи. Однако иметь такое количество чисел подряд становится трудно для чтения. Вторая строка кода показывает , как вы можете создать LocalDateи LocalTimeобъекты , отдельно, а затем объединить их , чтобы создать LocalDateTimeобъект.
Теперь существует много сигнатур методов, поскольку существует больше комбинаций. Подписи метода следующие:

public static LocalDateTime of(int year, int month,  int dayOfMonth, int hour, int minute)
public static LocalDateTime of(int year, int month,  int dayOfMonth, int hour, int minute, int second)
public static LocalDateTime of(int year, int month,  int dayOfMonth, int hour, int minute, int second, int nanos)
public static LocalDateTime of(int year, Month month,  int dayOfMonth, int hour, int minute)
public static LocalDateTime of(int year, Month month,  int dayOfMonth, int hour, int minute, int second)
public static LocalDateTime of(int year, Month month,  int dayOfMonth, int hour, int minute, int second, int nanos)
public static LocalDateTime of(LocalDate date, LocalTime time)
Для того, чтобы создать ZonedDateTime, нам сначала нужно получить нужный часовой пояс. Мы будем использовать US/Easternв наших примерах:

ZoneId zone = ZoneId.of("US/Eastern");
ZonedDateTime zoned1 = ZonedDateTime.of(2015, 1, 20,    6, 15, 30, 200, zone);
ZonedDateTime zoned2 = ZonedDateTime.of(date1, time1, zone);
ZonedDateTime zoned3 = ZonedDateTime.of(dateTime1, zone);
Начнем с получения объекта часового пояса. Затем мы используем один из трех подходов для создания ZonedDateTime. Первый проходит все поля индивидуально. Мы не рекомендуем такой подход - слишком много цифр, и их трудно прочитать. Лучший подход - передать LocalDateобъект и LocalTimeобъект или LocalDateTimeобъект.
Хотя есть и другие способы создания ZonedDateTime, вам нужно знать только три для экзамена:

public static ZonedDateTime of(int year, int month,  int dayOfMonth,
 int hour, int minute, int second, int nanos, ZoneId zone)
public static ZonedDateTime of(LocalDate date, LocalTime time, ZoneId zone)
public static ZonedDateTime of(LocalDateTime dateTime, ZoneId zone)
Обратите внимание, что в Monthперечислении нет опции для перехода . Это похоже на упущение со стороны создателей API и то, что будет исправлено в будущих версиях Java.
Нахождение часового пояса
Узнать свой часовой пояс легко. Вы можете просто распечатать ZoneId.systemDefault(). Если вы не знаете, что такое другой часовой пояс, Java предоставляет метод для перечисления поддерживаемых. Используя методы функционального программирования, которые вы изучили, вы можете легко распечатать отсортированный список потенциальных кандидатов:

ZoneId.getAvailableZoneIds().stream() 
 .filter(z -> z.contains("US") || z.contains("America")) 
 .sorted().forEach(System.out::println);
Это напечатало 177 строк, когда мы его запустили. Мы предпочитаем US/Easternчасовой пояс, America/New_Yorkтак как он более общий. Часовых поясов так много, потому что там много дублирования. При написании кода старайтесь использовать все, что наиболее понятно. В Соединенных Штатах большинство людей говорят «восточное», когда говорят о времени восточного побережья, поэтому нам нравится использовать это в коде.
Как вы знаете, что фильтровать? Попробуйте название страны или название города. Или вы можете распечатать все и посмотреть, хотя это. Или вы можете использовать Google, чтобы узнать название целевого часового пояса.
Вы заметили, что мы не использовали конструктор ни в одном из примеров? Классы даты и времени имеют частные конструкторы, чтобы заставить вас использовать staticметоды фабрики . Создатели экзамена могут бросить в вас что-то вроде этого:

LocalDate d = new LocalDate(); // DOES NOT COMPILE
Не поддавайтесь на это. Вам не разрешено создавать объекты даты или времени напрямую.
Другая хитрость заключается в том, что происходит, когда вы передаете недопустимые числа of(), например:
LocalDate.of(2015, Month.JANUARY, 32)     // throws DateTimeException
Вам не нужно знать точное исключение, которое выдается, но оно ясное:

java.time.DateTimeException: Invalid value for DayOfMonth  (valid values 1—28/31): 32

Создание дат в Java 7 и ранее
Вы можете увидеть некоторые проблемы со старым способом в Таблице 5.1. Не было способа указать только дату без времени. DateКласс представлен как дата и время , хотели ли вы его или нет. Попытка создать конкретную дату потребовала больше кода, чем следовало бы. Индексы месяца были 0, а не 1, что сбивало с толку.
Есть действительно старый способ создать дату. В Java 1.1, вы создаете специфический Dateс этим: Date jan = new Date(2015, Calendar.JANUARY, 1);. Вы можете использовать Calendarкласс, начиная с Java 1.2. Dateсуществует главным образом для обратной совместимости и для того, чтобы Calendarможно было работать с кодом - сделать новый путь третьим. Новый способ, как показано в Таблице 5.1 , намного лучше, так что похоже, что это случай, когда третий раз является обаянием!
Таблица 5.1 Старый и новый способ создания дат

	Старый Путь	Новый путь (Java 8 и новее)
Импорт	import  java.util.*;	import  java.time.*;
Создание объекта с текущей датой	Date d = new  Date();	LocalDate d =  LocalDate.now();
Создание объекта с текущей датой и временем	Date d = new  Date();	LocalDateTime dt  =  LocalDateTime. now();
Создание объекта, представляющего 1 января 2015 г.	Calendar c =  Calendar.getInstance(); 
c.set(2015,  Calendar.JANUARY, 1); 
Date jan = c.getTime();
 or Calendar c = new  GregorianCalendar(2015, Calendar.JANUARY, 1);
 Date jan = c.getTime();	LocalDate jan =  LocalDate.of(2015,  Month.JANUARY,  1);
Создание 1 января 2015 года без constant	Calendar c =  Calendar.getInstance(); 
c.set(2015, 0, 1); 
Date jan = c.getTime();	LocalDate jan =  LocalDate.of(2015, 1,  1)


Манипуляции с датами и временем
Добавить к дате легко. Классы даты и времени неизменны. Как вы узнали из главы 2 «Шаблоны и принципы проектирования», это означает, что нам нужно помнить о том, чтобы присваивать результаты этих методов ссылочной переменной, чтобы они не терялись.

12: LocalDate date = LocalDate.of(2014, Month.JANUARY, 20);
13: System.out.println(date);          // 2014–01–20
14: date = date.plusDays(2);
15: System.out.println(date);          // 2014–01–22
16: date = date.plusWeeks(1);
17: System.out.println(date);          // 2014–01–29
18: date = date.plusMonths(1);
19: System.out.println(date);          // 2014–02–28
20: date = date.plusYears(5);
21: System.out.println(date);          // 2019–02–28
Этот код хорош, потому что он делает то, на что он похож. Мы начинаем с 20 января 2014 года. В строке 14 мы добавляем к нему два дня и переназначаем его в нашу ссылочную переменную. В строке 16 мы добавляем неделю. Этот метод позволяет нам писать более понятный код, чем plusDays(7). Сейчас date29 января 2014 года. В строке 18 мы добавляем месяц. Это приведет нас к 29 февраля 2014 года. Однако 2014 год не високосный. (2012 и 2016 годы високосные.) Java умнаДостаточно понять, что 29 февраля 2014 года не существует, и это дает нам 28 февраля 2014 года вместо этого. Наконец, строка 20 добавляет пять лет.   
  29 февраля существует только в високосный год. Високосные годы - это годы, кратные 4 или 400, но не кратные 100. Например, 2000 и 2016 годы являются високосными, а 2100 - нет.
Есть также хорошие, простые способы вернуться назад во времени. На этот раз давайте поработаем с LocalDateTime:

22: LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
23: LocalTime time = LocalTime.of(5, 15);
24: LocalDateTime dateTime = LocalDateTime.of(date, time);
25: System.out.println(dateTime);          // 2020–01–20T05:15
26: dateTime = dateTime.minusDays(1);
27: System.out.println(dateTime);          // 2020–01–19T05:15
28: dateTime = dateTime.minusHours(10);
29: System.out.println(dateTime);          // 2020–01–18T19:15
30: dateTime = dateTime.minusSeconds(30);
31: System.out.println(dateTime);          // 2020–01–18T19:14:30
В строке 25 печатается исходная дата 20 января 2020 года в 5:15 утра. В строке 26 вычитается полный день, что приводит нас к 19 января 2020 года в 5:15 утра. В строке 28 вычитается 10 часов, показывая, что дата изменится, если часы заставляют его приспосабливаться, и это приводит нас к 18 января 2020 года, в 19:15 (7:15 вечера). Наконец, строка 30 вычитает 30 секунд. Вы можете видеть, что внезапно значение дисплея начинает показывать секунды. Java достаточно умен, чтобы скрыть секунды и наносекунды, когда мы их не используем.
Обычно методы даты и времени объединяются. Например, без операторов print предыдущий пример можно переписать следующим образом:

LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
LocalTime time = LocalTime.of(5, 15);
LocalDateTime dateTime = LocalDateTime.of(date, time)   .minusDays(1).minusHours(10).minusSeconds(30);

Когда вам нужно сделать много манипуляций, эта цепочка пригодится. Создатели экзамена могут попытаться обмануть вас двумя способами. Как вы думаете, что это печатает?

LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
date.plusDays(10);
System.out.println(date);
Он печатается 20 января 2020 года. Добавление 10 дней было бесполезно, потому что программа проигнорировала результат. Всякий раз, когда вы видите неизменяемые типы, обратите внимание на то, чтобы возвращаемое значение вызова метода не игнорировалось. Экзамен также может проверить, если вы помните, что включает в себя каждый из объектов даты и времени. Вы видите, что здесь не так?

LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
date = date.plusMinutes(1);     // DOES NOT COMPILE
LocalDateне содержит времени Это означает, что вы не можете добавить минуты к нему. Это может быть сложно в цепочечной последовательности операций сложения / вычитания, поэтому убедитесь, что вы знаете, какие методы в таблице 5.2 могут быть вызваны для каких типов.
Таблица 5.2 Методы вLocalDate,LocalTime,LocalDateTime, и ZonedDateTime

	Can Call on LocalDate?	Can Call on LocalTime?	Can Call on LocalDateTime  or  ZonedDateTime?
plusYears/ minusYears	да	нет	да
plusMonths/ minusMonths	да	нет	да
plusWeeks/ minusWeeks	да	нет	да
plusDays/ minusDays	да	нет	да
plusHours/ minusHours	нет	да	да
plusMinutes/ minusMinutes	нет	да	да
plusSeconds/ minusSeconds	нет	да	да
plusNanos/ minusNanos	нет	да	да

Манипулирование датами в Java 7 и ранее
Если вы посмотрите на весь код в Таблице 5.3, чтобы выполнить вычисления времени по-старому, вы поймете, почему Java необходимо обновить API даты и времени! Старый способ требовал много кода, чтобы сделать что-то простое.
Таблица 5.3 Старый и новый способ создания дат

	Старый Путь	Новый путь (Java 8 и новее)
Добавление дня	public Date addDay(Date date) {   Calendar cal =  Calendar.getInstance();   cal.setTime(date);   cal.add(Calendar.DATE, 1);   return cal.getTime(); }	public LocalDate addDay(LocalDate date)  {   return  date.plusDays(1); }
Вычитать день	public Date subtractDay(Date date) {   Calendar cal =  Calendar.getInstance();   cal.setTime(date);   cal.add(Calendar.DATE, -1);   return cal.getTime(); }	public LocalDate subtractDay(LocalDate date) {   return  date.minusDays(1); }
Работа с периодами
Теперь вы знаете достаточно, чтобы сделать что-то веселое с датами! Наш зоопарк выполняет мероприятия по обогащению животных, чтобы дать им что-то интересное. Главный зоопарк решил поменять игрушки каждый месяц. Эта система будет работать в течение трех месяцев, чтобы увидеть, как она работает.
public static void main(String[] args) { 
 LocalDate start = LocalDate.of(2015, Month.JANUARY, 1); 
 LocalDate end = LocalDate.of(2015, Month.MARCH, 30);  performAnimalEnrichment(start, end);}private static void
 performAnimalEnrichment(LocalDate start, LocalDate end) 
{
  LocalDate upTo = start; 
 while (upTo.isBefore(end)) {          // check if still before end  
 System.out.println("give new toy: " + upTo);   upTo = upTo.plusMonths(1);           // add a month  
} }

Этот код работает нормально. Это добавляет месяц к дате, пока не достигнет конечной даты. Проблема в том, что этот метод нельзя использовать повторно. Наш зоопарк хочет попробовать разные графики, чтобы увидеть, какой из них работает лучше всего.
Преобразование в long
LocalDateи LocalDateTimeиметь метод для преобразования себя в longэквиваленты по отношению к 1 января 1970 года. Эта специальная дата называется epoch. Что особенного в 1970 году? Это то, что Unix начал использовать для стандартов даты, поэтому Java использовала его повторно. И не волнуйтесь - вам не нужно запоминать имена для экзамена.
•	LocalDateимеет toEpochDay()количество дней с 1 января 1970 года.
•	LocalDateTimeи ZonedDateTimeиметь toEpochSecond(), что число секунд с 1 января 1970 года.
•	LocalTimeне имеет эпохального метода. Поскольку оно представляет собой время, которое может наступить в любой день, сравнивать его с 1970 годом не имеет смысла. Хотя экзамен делает вид, что часовых поясов не существует, вы можете задаться вопросом, не состоится ли этот особый 1 января 1970 года конкретный часовой пояс. Ответ - да. Это специальное время относится к 1 января 1970 года по Гринвичу (среднее время по Гринвичу). Гринвич находится в Англии, а GMT не участвует в переходе на летнее время. Это делает его хорошим ориентиром.
К счастью, в Java есть Periodкласс, который мы можем передать. Этот код делает то же самое, что и предыдущий пример:

public static void main(String[] args) {
  LocalDate start = LocalDate.of(2015, Month.JANUARY, 1); 
 LocalDate end = LocalDate.of(2015, Month.MARCH, 30); 
 Period period = Period.ofMonths(1);           
    // create a period 
 performAnimalEnrichment(start, end, period);
}
private static void performAnimalEnrichment(LocalDate start, LocalDate end,  
Period period) {     
          // uses the generic period
  LocalDate upTo = start; 
 while (upTo.isBefore(end)) {  
  System.out.println("give new toy: " + upTo); 
   upTo = upTo.plus(period);     // adds the period  
}
Метод может добавить произвольный промежуток времени, который передается. Это позволяет нам повторно использовать один и тот же метод для разных периодов времени, так как наш зоокейпер передумает.
Есть пять способов создать Periodкласс:
Period annually = Period.ofYears(1);               // every 1 year
Period quarterly = Period.ofMonths(3);             // every 3 months
Period everyThreeWeeks = Period.ofWeeks(3);        // every 3 weeks
Period everyOtherDay = Period.ofDays(2);           // every 2 days
Period everyYearAndAWeek = Period.of(1, 0, 7);     // every year and 7 days

Есть один улов. Вы не можете связывать методы при создании Period. Следующий код выглядит как everyYearAndAWeekпример, но это не так. Только последний метод используется, потому что Period ofметоды являются staticметодами.

Period wrong = Period.ofYears(1).ofWeeks(1);          // every week
Этот хитрый код действительно похож на написание следующего:

Period wrong = Period.ofYears(1);
wrong = Period.ofWeeks(1);
Это явно не то, что вы хотели! Вот почему of()метод позволяет передавать количество лет, месяцев и дней. Все они включены в один и тот же период. Вы получите предупреждение компилятора об этом. Предупреждения компилятора сообщают вам, что что-то не так или подозрительно, не компилируя.
of()Метод занимает лишь годы, месяцы и дни. Возможность использовать другой фабричный метод, чтобы провести недели, является просто удобством. Как вы можете себе представить, фактический период хранится в виде лет, месяцев и дней. Когда вы распечатываете значение, Oracle отображает любые ненулевые части, используя формат, показанный на рисунке 5.1 .
Рисунок 5.1 Формат периода
Как вы можете видеть, Pвсегда начинается, Stringчтобы показать, что это мера периода. Затем следует количество лет, количество месяцев и количество дней. Если какие-либо из них равны нулю, они опускаются.
Можете ли вы выяснить, что это выводит?

System.out.println(Period.ofMonths(3));
Выход есть P3M. Помните, что Java опускает любые меры, которые являются нулевыми. Давайте попробуем другое:

System.out.println(Period.of(0, 20, 47));
Выход есть P20M47D. Там нет лет, поэтому эта часть пропускается. Можно иметь больше дней, чем за месяц. Также можно иметь больше месяцев, чем за год. Java использует меры, предусмотренные для каждого.
Теперь давайте попробуем хитрый:


System.out.println(Period.ofWeeks(3));

Этот вывод P21D. Помните, что неделя не является одной из единиц Periodмагазинов. Поэтому неделя конвертируется в 7 дней. Так как у нас есть 3 недели, это 21 день.
Последнее, что нужно знать, Periodэто то, с какими объектами это можно использовать. Давайте посмотрим на некоторый код:

3: LocalDate date = LocalDate.of(2015, 1, 20);
4: LocalTime time = LocalTime.of(6, 15);
5: LocalDateTime dateTime = LocalDateTime.of(date, time);
6: Period period = Period.ofMonths(1);
7: System.out.println(date.plus(period));          // 2015–02–20
8: System.out.println(dateTime.plus(period));      // 2015–02–20T06:15
9: System.out.println(time.plus(period));   // UnsupportedTemporalTypeException

Строки 7 и 8 работают как положено. Они добавляют месяц к 20 января 2015 года, что дает нам 20 февраля 2015 года. У первого есть только дата, а у второго - и дата, и время.
Строка 9 пытается добавить месяц к объекту, у которого есть только время. Это не сработает. Java выдает исключение и жалуется, что мы пытались использовать Unsupported unit: Months.
Как видите, вам придется обращать внимание на тип объектов даты и времени в каждом месте, где вы их видите. 
 Работа с длительностями
Вы, наверное, уже заметили, что Periodэто день или больше времени. Существует также Duration, который предназначен для меньших единиц времени. Для Duration, вы можете указать количество дней, часов, минут, секунд, или наносекунд. И да, вы могли бы провести 365 дней, чтобы сделать год, но вы действительно не должны - вот для чего Period.
Удобно, Durationпримерно работает так же, как Period, за исключением того, что используется с объектами, которые имеют время. Помните, что Periodвыходной результат начинается с P. Durationвыводится начиная с PT, который вы можете рассматривать как период времени. A Durationхранится в часах, минутах и секундах. Количество секунд включает доли секунды.
Мы можем создать Durationнесколько различных гранулярностей:
Duration daily = Duration.ofDays(1);                // PT24H
Duration hourly = Duration.ofHours(1);              // PT1H
Duration everyMinute = Duration.ofMinutes(1);       // PT1M
Duration everyTenSeconds = Duration.ofSeconds(10);  // PT10S
Duration everyMilli = Duration.ofMillis(1);         // PT0.001S
Duration everyNano = Duration.ofNanos(1);           // PT0.000000001S
Это похоже на Period. Мы передаем число правильному методу. Мы также пытаемся сделать код читабельным. Мы могли бы сказать, Duration.ofSeconds(3600)чтобы означать один час. Это просто сбивает с толку. Хотя экзамен гордится своей путаницей, он не проверяет ваши математические способности в преобразовании единиц измерения.
Durationне имеет конструктора, который принимает несколько единиц, как это Periodделает. Если вы хотите, чтобы что-то происходило каждые полтора часа, вы должны указать 90 минут.
Durationвключает в себя еще один более общий фабричный метод. Требуется число и TemporalUnit. Идея, скажем, что-то вроде «5 секунд». Тем не менее, TemporalUnitэто интерфейс. На данный момент существует только одна названная реализация ChronoUnit.
Предыдущий пример можно переписать так:

Duration daily = Duration.of(1, ChronoUnit.DAYS);
Duration hourly = Duration.of(1, ChronoUnit.HOURS);
Duration everyMinute = Duration.of(1, ChronoUnit.MINUTES);
Duration everyTenSeconds = Duration.of(10, ChronoUnit.SECONDS);
Duration everyMilli = Duration.of(1, ChronoUnit.MILLIS);
Duration everyNano = Duration.of(1, ChronoUnit.NANOS)
ChronoUnitтакже включает в себя несколько удобных единиц, таких как ChronoUnit.HALF_DAYS12 часов.
ChronoUnit для различий
ChronoUnitотличный способ определить, как далеко друг от друга Temporalнаходятся два значения. Temporalвключает в себя LocalDate, LocalTimeи так далее.

LocalTime one = LocalTime.of(5, 15);
LocalTime two = LocalTime.of(6, 30);
LocalDate date = LocalDate.of(2016, 1, 20);
 System.out.println(ChronoUnit.HOURS.between(one, two));   // 1
System.out.println(ChronoUnit.MINUTES.between(one, two)); // 75
System.out.println(ChronoUnit.MINUTES.between(one, date)); // DateTimeException
Первый оператор печати показывает, что betweenусекает, а не округляет. Вторая показывает, как легко считать в разных единицах. Просто измените ChronoUnitтип. Последнее напоминает нам, что Java выдаст исключение, если мы смешаем то, что можно сделать с объектами даты и времени.
Использование Durationработает так же, как использование Period, например:
7:    LocalDate date = LocalDate.of(2015, 1, 20);
8:    LocalTime time = LocalTime.of(6, 15);
9:    LocalDateTime dateTime = LocalDateTime.of(date, time);
10:   Duration duration = Duration.ofHours(6);
11:   System.out.println(dateTime.plus(duration)); // 2015–01–20T12:15
12:   System.out.println(time.plus(duration));     // 12:15
13:   System.out.println(date.plus(duration));     // UnsupportedTemporalException
Строка 11 показывает, что мы можем добавить часы к a LocalDateTime, так как она содержит время. Строка 12 также работает, поскольку у нас есть только время. Строка 13 терпит неудачу, потому что мы не можем добавить часы к объекту, который не содержит время.
Давайте попробуем это снова, но на этот раз добавим 23 часа.
7:    LocalDate date = LocalDate.of(2015, 1, 20);
8:    LocalTime time = LocalTime.of(6, 15);
9:    LocalDateTime dateTime = LocalDateTime.of(date, time);
10:   Duration duration = Duration.ofHours(23);
11:   System.out.println(dateTime.plus(duration)); // 2015–01–21T05:15
12:   System.out.println(time.plus(duration));     // 05:15
13:   System.out.println(date.plus(duration));     // UnsupportedTemporalException

На этот раз мы видим, что Java продвигается дальше конца дня. Линия 11 идет на следующий день, так как мы проходим полночь. В строке 12 нет дня, поэтому время просто меняется, как на настоящих часах.
Помните это Periodи Durationне эквивалентны. Этот пример показывает Periodи Durationодинаковой длины:
LocalDate date = LocalDate.of(2015, 5, 25);
Period period = Period.ofDays(1);
Duration days = Duration.ofDays(1); 
System.out.println(date.plus(period)); // 2015–05–26
System.out.println(date.plus(days)); // Unsupported unit: Seconds

Поскольку мы работаем с LocalDateнами, мы обязаны использовать Period. Durationесть единицы времени, даже если мы их не видим, и они предназначены только для объектов со временем. Убедитесь, что вы можете заполнить таблицу 5.4, чтобы определить, какие объекты можно использовать Periodи Duration.
Таблица 5.4. Где использоватьDurationиPeriod

	Можно использовать с Period?	Можно использовать с Duration?
LocalDate	да	нет
LocalDateTime	да	да
LocalTime	нет	да
ZonedDateTime	да	да

Работа с Instants
InstantКласс представляет определенный момент времени в часовом поясе GMT. Предположим, что вы хотите запустить таймер:
Instant now = Instant.now();
//do something time consuming
Instant later = Instant.now();
 Duration duration = Duration.between(now, later);
System.out.println(duration.toMillis());
В нашем случае «что-то отнимает много времени» заняло чуть больше секунды, и программа распечаталась 1025.
Если у вас есть ZonedDateTime, вы можете превратить его в Instant:

LocalDate date = LocalDate.of(2015, 5, 25);
LocalTime time = LocalTime.of(11, 55, 00);
ZoneId zone = ZoneId.of("US/Eastern");
ZonedDateTime zonedDateTime = ZonedDateTime.of(date, time, zone);
Instant instant = zonedDateTime.toInstant(); // 2015–05–25T15:55:00Z
System.out.println(zonedDateTime); // 2015–05–25T11:55–04:00[US/Eastern]
System.out.println(instant); // 2015–05–25T15:55:00Z

Последние две строки представляют один и тот же момент времени. ZonedDateTimeВключает в себя временную зону. InstantИзбавляется от часового пояса и превращает его в Instantвремя в GMT.
Вы не можете конвертировать LocalDateTimeв Instant. Помните, что это Instantмомент времени. А LocalDateTimeне содержит часового пояса, и поэтому во всем мире он не является общепризнанным как один и тот же момент времени.
Если у вас есть количество секунд с 1970 года, вы также можете создать такой Instantспособ:

Instant instant = Instant.ofEpochSecond(epochSeconds);
System.out.println(instant);        // 2015–05–25T15:55:00Z

Используя это Instant, вы можете сделать математику. Instantпозволяет добавить любой день или меньше, например:
Instant nextDay = instant.plus(1, ChronoUnit.DAYS);
System.out.println(nextDay); // 2015–05–26T15:55:00Z
Instant nextHour = instant.plus(1, ChronoUnit.HOURS);
System.out.println(nextHour); // 2015–05–25T16:55:00Z
Instant nextWeek = instant.plus(1, ChronoUnit.WEEKS); // exception
Странно, что Instantотображает год и месяц, не позволяя вам делать математику с этими полями. К сожалению, вам нужно запомнить этот факт.  
Учет летнего времени
Некоторые страны наблюдают daylight savings time. Здесь часы настраиваются на час два раза в год, чтобы лучше использовать солнечный свет. Не все страны участвуют, и те, которые используют разные выходные для изменения.
В Соединенных Штатах мы переводим часы на час вперед в марте и переводим их на час назад в ноябре. Экзамен сообщит вам, если указанная дата / время выпадают на выходные, когда запланировано изменение часов. Если это не упомянуто в вопросе, вы можете предположить, что это нормальные выходные. Мы официально меняем наши часы в 2 часа ночи, которая выпадает очень рано утром в воскресенье.
На рисунке 5.2 показано, что происходит с часами. В обычный день время идет линейно с 1:00 до 2:00 до 3:00 до 4:00 и так далее. Когда мы меняем часы в марте, время переходит вперед с 1:59 до 3:00. Технически это 1:59 и 59 секунд плюс миллисекунды; иными словами, момент непосредственно перед 2:00 утра. К счастью, экзамен не является настолько детальным, и мы можем думать об этом как просто 1:59 утра.

LocalDate date = LocalDate.of(2016, Month.MARCH, 13);
LocalTime time = LocalTime.of(1, 30);
ZoneId zone = ZoneId.of("US/Eastern");
ZonedDateTime dateTime = ZonedDateTime.of(date, time, zone);
 System.out.println(dateTime); // 2016–03–13T01:30–05:00[US/Eastern] 
dateTime = dateTime.plusHours(1); 
System.out.println(dateTime); // 2016–03–13T03:30–04:00[US/Eastern]
Рисунок 5.2 Как работает летнее время
Когда мы меняем часы в ноябре, время возвращается назад, и мы переживаем время с 2:00 до 2:59. Дети учатся этому весной как весной, а осенью - осенью.
Другой способ взглянуть на это состоит в том, что в марте есть один день, который длится 23 часа, и один день в ноябре, который длится 25 часов. В программировании мы называем это крайним случаем. Oracle решил, что это достаточно важно, чтобы быть на экзамене. Это означает, что вы должны узнать об этом, даже если вы живете в стране, которая не участвует в переходе на летнее время.
Например, 13 марта 2016 года мы переводим часы на час вперед и прыгаем с 2:00 до 3:00. Это означает, что в этот день нет 2:30. Если бы мы хотели узнать время на час позже 1:30, было бы 3:30.

LocalDate date = LocalDate.of(2016, Month.NOVEMBER, 6);
LocalTime time = LocalTime.of(1, 30);
ZoneId zone = ZoneId.of("US/Eastern");
ZonedDateTime dateTime = ZonedDateTime.of(date, time, zone);
 System.out.println(dateTime); // 2016–11–06T01:30–04:00[US/Eastern] 
dateTime = dateTime.plusHours(1);
 System.out.println(dateTime); // 2016–11–06T01:30–05:00[US/Eastern]
 dateTime = dateTime.plusHours(1);
 System.out.println(dateTime); // 2016–11–06T02:30–05:00[US/Eastern]

Обратите внимание, что в этом примере изменяются две вещи. Время прыгает с 1:30 до 3:30. Смещение UTC также изменяется. Помните, когда мы рассчитывали время по Гринвичу, вычитая часовой пояс из времени? Вы можете видеть, что мы пошли с 6:30 по Гринвичу (1:30 минус -5: 00) до 7:30 по Гринвичу (3:30 минус -4: 00). Это показывает, что время действительно изменилось на один час с точки зрения GMT.
Точно так же в ноябре час после первоначального 1:30 также 1:30, потому что в 2:00 мы повторяем час. На этот раз попробуйте самостоятельно рассчитать время по Гринвичу для всех трех раз, чтобы подтвердить, что мы действительно возвращаемся только на один час за раз.
LocalDate date = LocalDate.of(2016, Month.MARCH, 13);
LocalTime time = LocalTime.of(2, 30);
ZoneId zone = ZoneId.of("US/Eastern");
ZonedDateTime dateTime = ZonedDateTime.of(date, time, zone);
System.out.println(dateTime);  // 2016–03–13T03:30–04:00[US/Eastern]
Java достаточно умен, чтобы знать, что в ту ночь нет 2:30, и переключается на соответствующее смещение по Гринвичу.
Да, досадно, что Oracle ожидает, что вы узнаете об этом, даже если вы не в Соединенных Штатах - или, если уж на то пошло, в той части Соединенных Штатов, которая не использует летнее время. Создатели экзаменов находятся в Соединенных Штатах, и они решили, что каждый должен знать, как работают часовые пояса Соединенных Штатов.
